import raylib::*;

BodyKind :: enum {
  Static,
  Rigid,
}

Body :: struct {
  kind: BodyKind,
  // scale of collider. position is taken from the gameobject.
  // maybe we'll have other kinds later.
  transform: Transform,
}

impl Body {
  resolve_collision :: fn(self, other: Body) -> Vector3 {
    mut self_corners: Vector3[8] = .[
      self.transform.translation + Vector3.{x: -self.transform.scale.x / 2.0, y: -self.transform.scale.y / 2.0, z: -self.transform.scale.z / 2.0},
      self.transform.translation + Vector3.{x:  self.transform.scale.x / 2.0, y: -self.transform.scale.y / 2.0, z: -self.transform.scale.z / 2.0},
      self.transform.translation + Vector3.{x: -self.transform.scale.x / 2.0, y:  self.transform.scale.y / 2.0, z: -self.transform.scale.z / 2.0},
      self.transform.translation + Vector3.{x:  self.transform.scale.x / 2.0, y:  self.transform.scale.y / 2.0, z: -self.transform.scale.z / 2.0},
      self.transform.translation + Vector3.{x: -self.transform.scale.x / 2.0, y: -self.transform.scale.y / 2.0, z:  self.transform.scale.z / 2.0},
      self.transform.translation + Vector3.{x:  self.transform.scale.x / 2.0, y: -self.transform.scale.y / 2.0, z:  self.transform.scale.z / 2.0},
      self.transform.translation + Vector3.{x: -self.transform.scale.x / 2.0, y:  self.transform.scale.y / 2.0, z:  self.transform.scale.z / 2.0},
      self.transform.translation + Vector3.{x:  self.transform.scale.x / 2.0, y:  self.transform.scale.y / 2.0, z:  self.transform.scale.z / 2.0}
    ];
    
    for i in 0..8 {
        self_corners[i] = Vector3RotateByQuaternion(
            self_corners[i] - self.transform.translation, 
            QuaternionFromEuler(self.transform.rotation.x, self.transform.rotation.y, self.transform.rotation.z))
        + self.transform.translation;
    }
    
    mut other_corners: Vector3[8] = .[
        other.transform.translation + Vector3.{x: -other.transform.scale.x / 2.0, y: -other.transform.scale.y / 2.0, z: -other.transform.scale.z / 2.0},
        other.transform.translation + Vector3.{x:  other.transform.scale.x / 2.0, y: -other.transform.scale.y / 2.0, z: -other.transform.scale.z / 2.0},
        other.transform.translation + Vector3.{x: -other.transform.scale.x / 2.0, y:  other.transform.scale.y / 2.0, z: -other.transform.scale.z / 2.0},
        other.transform.translation + Vector3.{x:  other.transform.scale.x / 2.0, y:  other.transform.scale.y / 2.0, z: -other.transform.scale.z / 2.0},
        other.transform.translation + Vector3.{x: -other.transform.scale.x / 2.0, y: -other.transform.scale.y / 2.0, z:  other.transform.scale.z / 2.0},
        other.transform.translation + Vector3.{x:  other.transform.scale.x / 2.0, y: -other.transform.scale.y / 2.0, z:  other.transform.scale.z / 2.0},
        other.transform.translation + Vector3.{x: -other.transform.scale.x / 2.0, y:  other.transform.scale.y / 2.0, z:  other.transform.scale.z / 2.0},
        other.transform.translation + Vector3.{x:  other.transform.scale.x / 2.0, y:  other.transform.scale.y / 2.0, z:  other.transform.scale.z / 2.0}
    ];
    
    for i in 0..8 {
        other_corners[i] = Vector3RotateByQuaternion(
            other_corners[i] - other.transform.translation, 
            QuaternionFromEuler(other.transform.rotation.x, other.transform.rotation.y, other.transform.rotation.z)) + other.transform.translation;
    }

    mut self_min := Vector3.{x: self_corners[0].x, y: self_corners[0].y, z: self_corners[0].z};
    mut self_max := Vector3.{x: self_corners[0].x, y: self_corners[0].y, z: self_corners[0].z};

    for i in 0..8 {
      corner := self_corners[i];
      self_min.x = min(self_min.x, corner.x);
      self_min.y = min(self_min.y, corner.y);
      self_min.z = min(self_min.z, corner.z);

      self_max.x = max(self_max.x, corner.x);
      self_max.y = max(self_max.y, corner.y);
      self_max.z = max(self_max.z, corner.z);
    }

    mut other_min := Vector3.{x: other_corners[0].x, y: other_corners[0].y, z: other_corners[0].z};
    mut other_max := Vector3.{x: other_corners[0].x, y: other_corners[0].y, z: other_corners[0].z};

    for i in 0..8 {
      corner := other_corners[i];
      other_min.x = min(other_min.x, corner.x);
      other_min.y = min(other_min.y, corner.y);
      other_min.z = min(other_min.z, corner.z);
      other_max.x = max(other_max.x, corner.x);
      other_max.y = max(other_max.y, corner.y);
      other_max.z = max(other_max.z, corner.z);
    }

    // Calculate the penetration depth
    penetration := Vector3.{
      x: min(self_max.x - other_min.x, other_max.x - self_min.x),
      y: min(self_max.y - other_min.y, other_max.y - self_min.y),
      z: min(self_max.z - other_min.z, other_max.z - self_min.z),
    };

    // Return the penetration vector
    if penetration.x < penetration.y && penetration.x < penetration.z {
      return Vector3.{
        x: penetration.x, 
        y: 0.0, 
        z: 0.0
      };
    } else if penetration.y < penetration.x && penetration.y < penetration.z {
      return Vector3.{
        x: 0.0, 
        y: penetration.y, 
        z: 0.0
      };
    } else {
      return Vector3.{
        x: 0.0, 
        y: 0.0, 
        z: penetration.z
      };
    }
  }
}
