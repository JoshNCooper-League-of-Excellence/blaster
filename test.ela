import physics::*;

#test test_body_no_collide :: fn() {
  a := Body.{
    transform: .{
      translation: Vector3::zero(),
      scale: Vector3::one(),
    }
  }
  b := Body.{
    transform: .{
      translation: Vector3::new(10.0, 10.0, 10.0),
      scale: Vector3::one(),
    }
  }
  collision := a.resolve_collision(b);
  assert("Bodies should not collide", collision.x == 0.0 && collision.y == 0.0 && collision.z == 0.0);
}

#test test_body_collide_with_scale :: fn() {
  a := Body.{
    transform: .{
      translation: Vector3::zero(),
      scale: Vector3::new(2.0, 2.0, 2.0),
    }
  }
  b := Body.{
    transform: .{
      translation: Vector3::new(1.0, 1.0, 1.0),
      scale: Vector3::one(),
    }
  }
  collision := a.resolve_collision(b);
  assert("Bodies should collide with scale", collision.x != 0.0 || collision.y != 0.0 || collision.z != 0.0);
}

#test test_body_collide_with_rotation :: fn() {
  a := Body.{
    transform: .{
      translation: Vector3::zero(),
      rotation: Quaternion::from_euler(0.0, 0.0, 0.0),
      scale: Vector3::one(),
    }
  }
  b := Body.{
    transform: .{
      translation: Vector3::new(0.5, 0.5, 0.5),
      rotation: Quaternion::from_euler(0.0, 0.0, 0.0),
      scale: Vector3::one(),
    }
  }
  collision := a.resolve_collision(b);
  assert("Bodies should collide with rotation", collision.x != 0.0 || collision.y != 0.0 || collision.z != 0.0);
}

#test test_body_no_collide_with_rotation :: fn() {
  a := Body.{
    transform: .{
      translation: Vector3::zero(),
      rotation: Quaternion::from_euler(0.0, 0.0, 0.0),
      scale: Vector3::one(),
    }
  }
  b := Body.{
    transform: .{
      translation: Vector3::new(10.0, 10.0, 10.0),
      rotation: Quaternion::from_euler(0.0, 0.0, 0.0),
      scale: Vector3::one(),
    }
  }
  collision := a.resolve_collision(b);
  assert("Bodies should not collide with rotation", collision.x == 0.0 && collision.y == 0.0 && collision.z == 0.0);
}